! it is just a draft of notes, they are yet to be completed anf finalised
# Design philosophy 
Go doesn't really like frameworks, it likes to focus on internal tools, external libs at max.
# Hello, world
Hello world code:
```go
package main

import "fmt"

func main() {
    fmt.Println("Hello, World")
}
```
* packages/dirs and stuff, imports and modules
* go linters and formatters
* why we state function returned value datatype last
* var naming conventions
# what is Go and how it is different form other langs
Concurrent
Garbage Collected 
Systems (where used and why)
Language 
* go vs cpp and other langs in perfomance
* tooling, profiling and what is built- in go what is usually not elsewhere
# modern world demands and how Golang addresses them
Lots of libs, huge dependence trees
(you can easuly use others code with go)
Architechtures are built aroundservices, which communicate online
Multicore processors even in mobile phones

* context freenes of golang
# development speed 
compillation takes lots of time 
tools are getting slower
amount of dependencies constantly grows
laptops are not becoming faster
projects cntinue to grow
# Goals of Go
efficiency of static typisation and usefullnes of dynamic one
type-safe and memory-safe
good multithreading support
efficient garbace collector, almost wthout stops
fast compilation
efficient work with large volumes of code
# design principles 
Go away

little amount of ortogonal features
simple syntax (both for humans and machines)
simple type system. object-oriented but doesn't implement inheritance. 

# echo 
```go
package main 

import (
    "fmt"
    "os"
)

func main() {
    var s, sep string
    for i := 1; i < len(os.Args[i]); i++ {
        s += sep + os.Args[i]
        sep = " "
    }
    fmt.Println(s)
}
```
golang utility from pres
# for loop 
Full form 
```go
for initialization; condition; post {
    // statements
}
```
Like while
```go
for condition {
    // statements
}
```
Infinite loop
```go
for {
    // statements
}
```
# echo2
```go
package main 

import (
    "fmt"
    "os"
)

func main() {
    s, sep := "",  ""
    for _, arg := range os.Args[1:] {
        s += sep + arg
        sep = " "
    }
    fmt.Println(s)
}
```
# Range 
Full form 
```go
for i, v := range slice {
    // ...
}
```

Just index 
```go
for i := range slice {
    // ...
}
```

Index not used
```go
for _, v := range slice {
    // ..
}
```
* how it is with strings
* go 1.22, taking values/var links from for cycle into the body goroutines
* fair, expensive/cheap copies

# var init 
```go
s := ""
var s = ""
var s string
var s string = ""
```
* actuality of each method
* generics

# uniq
```go
package main

import (
	"bufio"
	"fmt"
	"os"
)

func main() {
	counts := make(map[string]int)
	input := bufio.NewScanner(os.Stdin)
	for input.Scan() {
		counts[input.Text()]++
	}

	for line, n := range counts {
		fmt.Println("%d \t %s\n", n, line)
	}
}
```
* uniq linux utility
* go panics 
8 no prefix increment in go

# Printf
Formating functions end on f (fmt.Errorf, log.Printf).
```
%d - decimal integer
%x, $o, %b - integer in hexade cimal, octal, binary
%f, %g, %e - floating point number
%t - boolean
%c - rune (unicode code point)
%s - string
%q - quoted string "abc" or rune 'c'
%v - any value in a natural format
%T - type of any value
%% - literal percent sign
```

# urlfetch
```go
func main() {
    for _, url := range os.Args[1:] {
        resp, err := http.Get(url)
        if err != nil {
            fmt.Fprintf(os.Stderr, "fetch %v\n", err)
            os.Exit(1)
        }
        b, err := ioutil.ReadAll(resp.Body)
        resp.Body.Close()
        if err != nil {
            fmt.Fprintf(os.Stderr, "fetch: reading %s: %v\n", url, err)
            os.Exit(1)
        }
        fmt.Printf("%s", b)
    }
}
```
* go has no exceptions, just errors

# fetchall 
```go
func main() {
    start := time.Now()
    ch := make(chan string)
    for _, url := range os.Args[1:] {
        go fetch(url, ch) // start a goroutine
    }
    for range os.Args[1:] {
        fmt.Println(<-ch) // receive from channel ch
    }
    fmt.Printf("%.2fs elapsed\n", time.Since(start).Seconds())
}
```

```go
func fetch(url string, ch chan<- string) {
    start := time.Now()
    resp, err := http.Get(url)
    if err != nil {
        ch <- fmt.Sprint(err) // send to channel ch
        return
    }
    defer resp.Body.Close()

    nbytes, err := io.Copy(ioutil.Discard, resp.Body)
    if err != nil {
        ch <- fmt.Sprintf("while reading %s: %v", url, err)
        return
    }
    secs := time.Since(start).Seconds()
    ch <- fmt.Sprintf("%.2fs %7d %s", secs, nbytes, url)
}
```
* whats the point of <- in chanell in function signature

# webserver
```go
package main

import (
    "fmt"
    "log"
    "net/http"
)

func main() {
    http.HandleFunc("/", handler) // each request call hadler 
    log.Fatal(htt.ListenAndServe("localhost:8000", nil))
}

func handler(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, "URL.Path = %q\n", r.URL.Path)
}
```

# counter 
```go
var (
    counter int
    mu sync.Mutex
)

func main() {
    http.HandleFunc("/", handler)
    log.Fatal(http.ListenAndServe("localhost:8080", nil))
}

func handler(w http.ResponseWriter, r *http.Request) {
    var i int
    mu.Lock()
    i = counter
    counter++
    mu.Unlock()

}
```
* atomics for this example
* how goroutines are lighter than threads 

# switch
```go
switch coinflip() {
case "heads":
    heads++;
case "tails":
    tails++;
default:
    fmt.Println("Landed on edge")
}
```
tagless switch 
```go
func Signum(x int) int {
    switch {
    case > 0:
        return +1
    default:
        return 0
    case < 0:
        return -1
    }
}
```
* order of execution

# Struct 
```go
type Point struct {
    X, Y int
}
var p Point
```

# Pointers
```go
var s string
p = &s
s2 = *p

var p Point
p.X = 1

var pp *Point
pp.X = 1
```

# Additional resources 
Effective go
Std docs
Go FAQ
Code Review Comments

# Seminar
- Go installation
- goimports, gofmt
- IDE set up
- linters
- based go commands

golang/go

# if, switch, for
# Command line arguments
# Word count 
# Animated gif
# Fetching URL 
# Fetching URL concurrently
# Web server 
# Tour of go
# Local IDE setup 
# Submitting solutions to automated grading 
# gofmt 
# goimports 
# linting