! it is just a draft of notes, they are yet to be completed anf finalised
* go talks 
# Key words
There 25 keywords in go:
```go
break 
case
chan
const 
continue 

default
defer
else
fallthrough
for 

func 
go 
goto
if 
import

interface
map
package
range 
return

select
struct
switch
type
var
```
* generic types

# Predeclared identifiers
## Constants
```go
true false iota nil 
```
## Types
```go
any comparable int int8 in16 int32 in64
uint uint8 uint16 uint32 uint64 uintptr
float32 float64 complex64 complex128
bool type rune string error
```
## Functions
```go
min max len make cap new append clear copy close delete
complex real imag
panic recover
```
## identifiers cant be reassigned with regular rules (but shouldn't)
```go
var true = false
```
* in what exact file they are identified
* karatsuba, algs for long number multiplications, fft

# Exported identifiers
Capitalisation of the first letter determines wether that object is accessible from outside the pachage.
```go
package example
const c = 1 // inaccessible from outside the package
const C = 1 // accessible from outside the package
// same with vars, types and functions
```
Packages are always named with non-capital letters:
```go
fmt
net
grpcmiddleware
```

# Declarations
- There are only 4 types of declarations in go:
1. var
2. const
3. type
4. func
- Package consists of .go files
- Declaration order doesn't matter

# var
General form:
```go
var name type = expression
```

# short var declaration
```go
i, j := 0, 1 // when following syntax is used, at least one new var should be created
```
* can't use in global scope
* about scopes when giving value to existing vars
* type safeness and var reassigning

# pointers
```go
x := 1
p := &x // p, of type *int, points to x
fmt.Println(*p) // 1
*p = 2
fmt.Println(x) // 2
```
[Good pointers explanation](https://youtu.be/2XEQsJLsLN0?si=Nc3HxFgqzk4Zp2tJ)
* article form chat

# escape analysis
```go
var p = f()

func f() *int {
    v := 1 
    return &v
}
```
* dangling pointers or smth 
* learn more thoroughly
* acessibility graph, how is used with vars

# flag
```go
package main

import (
    "flag"
    "fmt"
    "strings"
)

var (
    n = flag.Bool("n", false, "omit trailing newline")
    sep = flag.String("s", " ", "separator")
)

func main() {
    flag.Parse()
    fmt.Println(strings.Join(flag.Args(), *sep))
    if !*n {
        fmt.Println()
    }
}
```
* study that code in more detail

# new
new(T) creates a new var with type *T
```go
func newInt() *int {
    return new(int)
}

func newInt() *int {
    var dummy int 
    return &dummy
}
```
* type casting in go

# zero size type
```go
p := new(int)
q := new(int)
fmt.Println(p == q) // "false"

p := new(struct{})
q := new(struct{})
fmt.Println(p == q) // "true" or "false" depending on implementation

a := [1_000_000_000]struct{}{}
fmt.Println(unsafe.sizeof(a)) // 0
```
* more thorough explanation

# variable lifetime 
Memory is spared after the var becomes unreachable.
Compiler may move var from stack to heap.
```go
var global *int
func f() {
    var x int
    x = 1
    global = &x
}
```
And from heap to stack.
```go
func g() {
    y := new(int)
    *y = 1
}
```
* are all thenumeric values stored somewhere fixed in memory
* general ideas about var storage, call stacks and so on
* link with explanation of algorythm for moving vars to stacks/heaps
* no escape directive

# type declaration
```go
type name underlying_type
```

```go
package tempconv

type Celsius float64
type Fahrenheit float64

const (
    AbsoluteZeroC Celsius = -273.15
    FreezingC Celsius = 0
    BoilingC Celsius = 100
)
func CToF(c Celsius) Fahrenheit {return Fahrenheit(c * 9 / 5 + 32)}
func FTOC(f Fahrenheit) Celsius {return Celsius((f - 32) * 5 / 9)}
```
## type alias
```go
type name = another_type
```
* constants don't have types?
* diff between alias and new type def

# packages
- File tempconv/types.go
```go
package tempconv

import "fmt"

type Celsius float64
type Fahrenheit float64

const (
    AbsoluteZeroC Celsius = -273.15
)

func (c Celsius) String() string {return fmt.Sprintf("%g C", c)}
func (f Fahrenheit) String() string {return fmt.Sprintf("%g F", f)}
```
- File tempconv/conv.go
```go
func CToF(c Celsius) Fahrenheit {return Fahrenheit(c * 9 / 5 + 32)}
func FTOC(f Fahrenheit) Celsius {return Celsius((f - 32) * 5 / 9)}
```
* Hierarchy and nested packages, modules

# package initialization
Go compiler determines init order of all the entities by itself.
* may provide an example.
* init with init function, why is it antipattern and when it is justified

# scope
# scope if 
* why first option is right if one on error is returned

# strings
string - unchangable byte sequence
s[i] - accesses i-th byte, not symbol
So we can't alter existing strings, only create new ones.

# unicode 
All symbols are encoded with 32 bit numbers:
```go
type rune = int32
```
utf8 encoding:
```
0xxxxxxx                              runes 0−127
110xxxxx 10xxxxxx                     128−2047
1110xxxx 10xxxxxx 10xxxxxx            2048−65535
11110xxx 10xxxxxx 10xxxxxx 10xxxxxx   65536−0x10ffff
```
* example form pres
Difference between runes and bytes:
```go
import "unicode/utf8"

func countRunes() {
    s := "Hello, 世界"
    fmt.Println(len(s)) // "13"
    fmt.Println(utf8.RuneCountInString(s)) // "9"
}
```
* phano condition
* example form pres

# utf8
```go
for i := 0; i < len(s); {
    r, size := utf8. DecodeRuneInString(s[i ])
    ft. Printf ("%d\t %c\n", i, r)
    i += size
}
```
Декодирование utf8 встроено в язык
```go
for i, rm := range "Hello, ti" {
    fmt.Printf("%d\t%q\t%d\n", i, r, r)
}

runes := []rune("Hello, ti")
s := string(runes)
```
Некорректный байт превращается unicode replacement character '\uFFFD'.
• Может ли строка string([]rune(s) ) быть больше s?

# stdlib
- strings: HasSuffix, Split, Joint, etc
- bytes: analog of strings for []byte
- unicode: isDigit, isLetter
- strconv: convertation between str and int, float
- path: work with unix routes
- filepath: work with current platform path (better use it) 
* unix paths

# []byte
```go
s := "abc"
b := []byte(s) // new byte sclice is being created
s2 := string(b)
```
* learn more thoroughly

# bytes.Buffer
```go
func intsToBytes(values []int) []byte {
    var buf bytes.Buffer
    buf.WriteByte('[')
    for i, v := range values {
        if i > 0 {
            buf.WriteString(", ")
        }
        fmt.Fprintf(&buf, "%d", v)
    }
    buf.WriteByte(']')
    return buf.Bytes()
}
```
* better assemble strings with string builder not bytes buffer
* what that buffer technically is
* i/o writer interface

# constants
```go
const (
    a = 1
    b
    c = 2
    d
)

fmt.Println(a, b, c, d) // "1 1 2 2"

type Weekday int 
const (
    Sunday Weekday = iota // 0
    Monday // 1
    Tuesday // 2
)

type Flags uint
const (
    FlagUp Flags = 1 << iota // is up
    FlagBroadcast // supports broadcast access capability
    FlagLoopback // is a loopback interface
    FlagPointToPoint // belongs to a point-to-point link
    FlagMulticast // supports multicast access capability
)
```
* if iota is correct, 1 << iota
* what if const name, more about constants

# untyped constants
```go
const (
    _ = 1 << (10 * iota)
    KiB
    MIB
    GiB
    PiB
    EiB
    YiB
    TiB // (exceeds 1 << 32)
    ZiB // (exceeds 1 << 64)
    YiB
)
```
Compiler guarantees min 256 bit precisivness
```go
fmt.Println(YiB/ZiB) // "1024"
```
* more thorough explanation of that code

# arrays
```go
var a [3]int
var q [3]int = [3]int{1, 2, 3}
var r [3]int = [3]int{1, 2}

d := [...]int{1, 2, 3}
h := [...]int{99: -1}
```
Arrays are values:
```go
func zero(ptr *[32]byte) {
    *ptr = [32]byte{}
}
```
Array size is fixed.
* what we can use as keys and what not

# slices
Slice is a tuple - data, len, cap.
```go
s := make([]int, 10)
s = s[:0]
s = s[:10]
s = s[:5:5]
s = s[:10] // panic
```
make is equivalent to the following code:
```go
a := [10]int{}
s := a[:] //
```
* where are slices and arrays stored, general storage organisation low level

```go
// reverses a slice of ints in place
func reverse(s []int) {
    for i, j := 0, len(s) - 1; i < j; i, j = i+1, j - 1 {
        s[i], s[j] = s[j], s[i]
    }
}
```

```go
var a, b []string
// a == nil && b == nil
fmt.Println(a == b) // invalid operation: a == b (slice can only be compared to nil)

var c []int // if zero value if enought
d := []int{}

// c == nil && d != nil
// len(c) == 0 && len(d) == 0
```
* reference and other datatypes

```go
make([]T, len) // len == cap
make([]T, len, cap)

func append(s []T, elem ...T) []T

var s []int
s = append(s, 1)
s = append(s, 2, 3)

var a, b []int
a = append(a, b...)

sCopy := append([]int(nil), s...) // use slices.Clone instead
```

# stack
```go
stack := append(stack, v) // push v
top := stack[len(stack) - 1] // top of stack
stack := stack[:len(stack) - 1] // pop
```

# queue
```go
queue = append(queue, v) // push v
front := queue[0] // front of queue
queue = queue[1:] //pop
```
O(1) is amortised time of all operations
Not so efficient by allocation amount
* learn more thoroughly

# copy
```go
func remove(slice []int, i int) []int {
    copy(slice[i:], slice[i+1:])
    return slice[:len(slice)-1]
}
```
* why is copy useless with generics?

# maps
```go
age := make(map[string]int)

ages := map[string]int {
    "alice": 31, 
    "charlie": 34,
}

ages := make(map[string]int)
ages["alice"] = 31
ages["charlie"] = 34
```

```go
ages["alice"] = 32
fmt.Println(ages["alice"]) // "32"
fmt.Println(ages["bob"]) // "0"

delete(ages, "alice")

ages["bob"] += 1
ages["bob"]++
_ = &ages["bob"] // compile error: cannot take address of map element

clear(ages)
```

```go
for name, age := range age {
    fmt.Printf("%s\t%d\n", name, age)
}

var ages map[string]int // if inited without make it is useless 
fmt.Println(ages == nil) // "true"
fmt.Println(len(ages) == 0) // "true"
fmt.Println(ages["alice"])  // "0"
ages["alice"] = 21 // panic
```

```go
age, ok := ages["bob"]
if !ok { /* "bob" is not a key in this map; age == 0. */ }
if age, ok := ages["bob"]; !ok {/* .. */ }
```

# set
```go
var s0 map[string]bool
var s1 map[string]struct{} // it is better
```

# struct 
```go
type Employee struct {
    ID int
    Name string 
    Address string
    Salary int
}

var dilbert Employee
dilber.Salary -= 5000
``` 

```go
type tree struct {
    value int
    left, right *tree
}
```

```go
type Point struct{ X, Y int }
p := point{1, 2}
p := Point{X: 1, Y: 2}
```

* using structs as keys
* comparing structs

# struct embedding
```go
type Point struct {
    X, Y int
}

type Circle struct {
    Point
    Radius int
}

c := Circle{
    Point: Point{X: 10, Y: 10},
    Radius: 1,
}

c.X = 0
```
* embedding vs polymorphysm (there is a link)

# json
```go
type Movie struct {
    Title string
    Year int `json:"year"`
    Color bool `json:"color,omitempty"`
    Actors []string
}
```
marshall:
```go
data, err := json.Marshal(movies)
if err != nil {
    log.Fatalf("JSON marshaling failed: %s", err)
}
fmt.Printf("%s\n", data)

data, err := json.MarshalIndent(movies, "", "   ")
if err != nil {
    log.Fatalf("JSON marshaling failed: %s", err)
}
fmt.Printf("%s\n", data)
```
* reflection

# unmarshal
```go
var movie Movie
if err := json.Unmarshal(data, &movie); err != nil {
    log. Fatalf( "JSON unmarshaling failed: %s", err)
}
fmt.Println(movie)
```

# github
```go
func SearchIssues(terms []string) (*IssuesSearchResult, error) {
    q := url.QueryEscape(strings.Join(terms, ""))
}
```